# Given a FASTQ file generated by a long-read sequencer such as PacBio,
# this script aligns the reads to a reference genome, identifies structural variants (SVs),
# and summarizes the detected SVs with relevant information.
#
# Dependencies:
# 1) Input data:
#    - Reference genome in FASTA format
#    - Optional prebuilt Minimap2 index (.mmi) corresponding to the reference
#    - A FASTQ file generated by a long-read sequencer (e.g., PacBio)
#
# 2) External tools (tested versions):
#    - seqkit    v2.10.1
#    - minimap2  v2.30-r1287
#    - sniffles2 v2.6.3
#
# TO RUN: python ./longread_sv_pipeline.py -f <FASTQ input file> -r <reference FASTA> [-i <reference index>]
# For example: python ./longread_sv_pipeline.py -f ./TestData/brca1_with_sva_hifi.fastq -r ~/human_reference_genome.fasta -i ~/ref.mmi

import argparse
import subprocess
from pathlib import Path

# Given a dictionary of FASTQ statistics,
# check basic properties to confirm that the file appears to be a valid
# long-read dataset.
def is_fastq_valid_longread(stats):
    num_reads = int(stats.get("num_seqs", 0).replace(",", ""))
    avg_len = float(stats.get("avg_len", 0).replace(",", ""))
    min_len = float(stats.get("min_len", 0).replace(",", ""))

    issues = []
    if num_reads == 0:
        issues.append("no reads found in FASTQ file")
    if avg_len < 1000:
        issues.append(f"average read length ({avg_len:.0f} bp) is unusually short for HiFi data")
    if min_len < 100:
        issues.append(f"some reads are extremely short (min length {min_len:.0f} bp)")
    
    if issues:
        return (False, "\n".join(issues))
    return (True, "")

# Print a summary of a FASTQ fileâ€™s statistics and return a dictionary of those values.
def summarize_fastq(fastq_path):
    try:
        result = subprocess.run(
            ["seqkit", "stats", fastq_path],
            check=True,
            text=True,
            capture_output=True
        )

        lines = result.stdout.strip().splitlines()

        header = lines[0].split()
        values = lines[1].split()

        stats = dict(zip(header, values))

        print(result.stdout.strip())
        print("\n")
        
        return stats

    except subprocess.CalledProcessError as e:
        print(f"Error running seqkit: {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=(
            "A pipeline for detecting structural variants in long-read sequencing data."
        )
    )
    parser.add_argument(
        "-r", "--reference",
        type=Path,
        required=True,
        help="Path to the reference genome in FASTA format."
    )
    parser.add_argument(
        "-f", "--fastq",
        type=Path,
        required=True,
        help="Path to the sample data FASTQ file generated by a long-read sequencer."
    )
    parser.add_argument(
        "-i", "--index",
        type=Path,
        required=False,
        help="Optional path to a prebuilt minimap2 index (.mmi). "
             "If not provided, the index will be generated automatically."
    )
    args = parser.parse_args()

    # TODO - check that dependencies are installed

    # Verify that the FASTQ file appears to contain valid long-read data
    print("\n=== FASTQ Summary (seqkit stats) ===")
    fastq_stats = summarize_fastq(args.fastq)
    is_valid = is_fastq_valid_longread(fastq_stats)
    if not is_valid[0]:
        response = input(f"Your input FASTQ file has some issues:\n{is_valid[1]}. \n\nDo you want to continue? (y/n)")
        if response != "y":
            exit()